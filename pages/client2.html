<!doctype html>
<html>
  <head>
   <title>THE LAST CLOUD</title>
  <meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<script src="/socket.io/socket.io.js"></script>
  <script src="./jcubic/js/jquery-1.7.1.min.js"></script>
  <script src="speakClient.js"></script>
  <!-- vine link -->
  <script src="https://platform.vine.co/static/scripts/embed.js"></script>
  <!-- my libs -->
	<script src="js/bt.js"></script>
	<script src="js/lc-playlist-textinput.js"></script>
	<script src="js/translator3.js"></script>
	<script src="js/nexusUI.js"></script>
	<script src="js/mcluhan.js"></script>
	<!-- cannot use .min because scrambles global 'm' variable -->
	<link href='http://fonts.googleapis.com/css?family=Anonymous+Pro:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="css/client.css">
		<script src="js/jquery-ui.js"></script>
		 <script src="https://maps.googleapis.com/maps/api/js?v=3.exp"></script>
  </head>
  <body>


	<div id="shell">
		<div class="guides">

			<!--<button onclick="m.static.begin()">Begin</button>-->

			<canvas id="presence" style="position:absolute;top:0px;left:0px;border:solid 1px #158;"></canvas>

			<div id="playlistvis" style="position:relative;height:100%;background-color:white;opacity:0.7">
				
				<div id="code-entries" style="position:absolute;bottom:22px;font-size:12px;line-height:13px;text-align:left;border:solid 0px blue;height:auto;padding:5px"></div>

				<div id="code-typing" style="position:absolute;bottom:0px;font-size:12px;text-align:left;border-top:solid 1px #000;padding:5px;width:100%;height:12px"></div>

			</div>

			<!-- <footer>&copy; 2016 Ben Taylor</footer> -->

		</div>
	</div>

	<div id="main">

  	

	</div>


	<script>

				var mediatotal = 0
				var medialoaded = 0

				$(function() {

					NProgress.start()

					// will become m.client.setup
					m.client.setup({
						w: 400,
						h: 300,
						x: 0.5,
						y: 0.5,
						bg: "#eee",
						text: "#333",
						type: "static"
					})

					m.mediapaths = [ "images/ios7icon-01.png" ]
					for (var i=0;i<m.mediapaths.length;i++) {
						m.mediapaths[i] = {
							path: m.mediapaths[i],
							image: new Image()
						}
						m.mediapaths[i].image.src = m.mediapaths[i].path
					}
					console.log(m.mediapaths)



				})



				var socket = io();

				// chat data
				socket.on('updatedata', function (type, data) {

					console.log(type)
					if (type=="entry") {
						$("#code-entries").append("<br>"+data.command)
						$("#code-typing").html("")
						evalIncomingEntry(data)
					} else if (type=="typing") {
						$("#code-typing").html(data)
					} else if (type=="createwall") {
						walls[data] = new wall("line")
					} else if (type=="removeentry") {
						console.log("removing", data)
						removeEntry(data)
					} else if (type=="changeentry") {
						changeEntry(data)
					}

				})



				// presence data
				socket.on('updatepresence', function (data) {
					rcvPresence.update(data)
				});

				// receives the paths to media to preload
				socket.on('mediapaths', function (type, data) {

					if (type=="images") {
						m.media.images = data
						mediatotal += m.media.images.length
						for (var i=0;i<m.media.images.length;i++) {
							console.log("load: "+m.media.images[i])
							m.media.images[i] = {
								path: m.media.images[i],
								data: new Image()
							}
							m.media.images[i].data.onload = function(data) {
								
								console.log("loaded:", medialoaded)
								medialoaded++
								NProgress.set(medialoaded/mediatotal)
								if (medialoaded/mediatotal>=0.9) {
									NProgress.done()
									$('#splash').fadeOut()
								}
							}
							m.media.images[i].data.src = m.media[type][i].path
						}
					} else if (type=="video") {
						m.media.video = data
						mediatotal += m.media.video.length
						for (var i=0;i<m.media.video.length;i++) {
							console.log("load: "+m.media.video[i])
							m.media.video[i] = {
								path: m.media.video[i],
								data: document.createElement("video")
							}
							//console.log("====", m.media.video[i])
							m.media.video[i].data.addEventListener('canplaythrough',function(data) {
								
								console.log(medialoaded/mediatotal)
								medialoaded++
								NProgress.set(medialoaded/mediatotal)
								if (medialoaded/mediatotal>=0.9) {
									NProgress.done()
									$('#splash').fadeOut()
								}
							})
							m.media.video[i].data.src = m.media[type][i].path
						}
					} else if (type=="audio") {
						m.media.audio = data
						mediatotal += m.media.audio.length
						for (var i=0;i<m.media.audio.length;i++) {
							console.log("load: "+m.media.audio[i])
							m.media.audio[i] = {
								path: m.media.audio[i],
								data: new Audio()
							}
							m.media.audio[i].data.addEventListener('canplaythrough', function(data) {
								console.log(data)
								medialoaded++
								NProgress.set(medialoaded/mediatotal)
								console.log(medialoaded/mediatotal)
								if (medialoaded/mediatotal>=0.9) {
									NProgress.done()
									$('#splash').fadeOut()
								}
							})
							m.media.audio[i].data.src = m.media[type][i].path
						}
					}

				})

				
				socket.on('settings', function (settings) {
					m.settings = settings
					for (var key in settings.patterns) {
						m.patterns[key] = m.settings.patterns[key]
					}
				})


	/* this gets the "presence" canvas in coding.html ...
		if want to send presence through network or add to a Wall,
		will need to generate this second canvas programatically
	*/
	var rcvPresence = {}
	rcvPresence.defaultSize = {w: 400, h: 300}
	rcvPresence.canvas = document.getElementById("presence")
	rcvPresence.canvas.style.height = rcvPresence.defaultSize.h;
	rcvPresence.canvas.style.width = rcvPresence.defaultSize.w;
	rcvPresence.canvas.width = rcvPresence.defaultSize.w;
	rcvPresence.canvas.height = rcvPresence.defaultSize.h;
	rcvPresence.context = rcvPresence.canvas.getContext('2d');
	rcvPresence.update = function(data) {
    //this.context.clearRect(0,0,this.canvas.width,this.canvas.height)
    this.context.fillStyle = "#000"
    this.context.fillRect(0,0,this.canvas.width,this.canvas.height)
		var dim = this.canvas.height / data.length
    var w = this.canvas.width
    var h = this.canvas.height
	  for (var i=0;i<data.length;i++) {
      for (var j=0;j<data[i].length;j++) {
        // i means which row
        // j means which column
        var placex = j*dim;
        var placey = i*dim;
       	/* if (data[i][j] > 0) {
        	this.context.fillStyle = "#333"
        } else {
		      this.context.fillStyle = "#fff"
        } */ 
        /* basic grayscale */
        this.context.fillStyle = "#" + data[i][j] + data[i][j] + data[i][j]
        this.context.fillRect(placex,placey,dim,dim)
        /* text
        this.context.fillStyle = "#000"
        this.context.fillText(vidtext[data[i][j]],placex,placey,dim,dim) */
        /* a little trippy
        this.context.fillStyle = "#" + data[i][j] + data[i][j] + data[i][j]
        var box = dim * m.random(10)/10
        this.context.fillRect(placex + (dim - box)/2,placey + (dim - box)/2,box+1,box+1)
        */
       
      }
    }
	}

  var vidtext = "#@*xoi!~.`"



			//general

			m.deck(8)
			m.variables = []

		  var current = {
    		wall: "",
    		media: "",
    		type: "",
    		params: ""
    	}

    	var black = {test: "thing"}

    	var local = {
    		context: "black",
    		walls: [],
    		nextWall: function() {
    			var colori = local.walls.indexOf(local.context)
    			colori++
    			if (colori >= local.walls.length) {
    				colori = 0
    			}
    			return local.walls[colori];
    		},
    		intervals: {}
    	}

		
		var walls = []


		function evalIncomingEntry(data) {

			console.log("evalling")
			//IF NO BEAT
			if (!data.duration) {

				console.log("no beat")

				data.gencode = createGens(data.index,data.code)
				if (data.reference) {
					with (m.variables[data.reference]) {
						console.log("evalling with reference")
						eval(data.gencode)
					}
				} else {
					with (eval(walls[data.wall])) {
						console.log("evalling with wall", data.wall)
						m.variables[data.index] = eval(data.gencode)
					}
				}
				
			//IF A BEAT		
			} else {
				console.log("a beat + right place")
				console.log(data.duration)
				
				data.gencode = createGens(data.index,data.code)
				distant.intervals["line"+data.index] = interval(data.duration,function(data) {
						if (data.reference) {
							with (m.variables[data.reference]) {
								eval(data.gencode)
							}
						} else {
							with (eval(walls[data.wall])) {
								m.variables[data.index] = eval(data.gencode)
							}
						}
				}.bind(this,data))
				
			}
		
		}

		function removeEntry(data) {
			console.log("removeEntry called")
			//clearInterval(distant.intervals["line"+data.index])
			if (distant.intervals["line"+data.index]) {
				distant.intervals["line"+data.index].stop()
			}
			if (data.newmedia) {
				m.variables[data.index].kill()
			}

		}

		function changeEntry(data) {
			//clearInterval(distant.intervals["line"+data.index])
			//distant.intervals["line"+data.index] = setInterval(data.function,data.delay)
			distant.intervals["line"+data.index].event = data.function
			distant.intervals["line"+data.index].ms(data.delay)

		}


	    /* Ben Library */

	    var Counter = function(limit) {
	    	this.max = 0;
	    	this.current = -1;
	    	this.tick = function() {
	    		this.current++;
	    		if (this.current>=this.limit) {
	    			this.current = 0;
	    		}
	    		return this.current;
	    	}
	    	this.downtick = function() {
	    		this.current--;
	    		if (this.current <= this.limit) {
	    			this.current = this.limit-1;
	    		}
	    		return this.current;
	    	}
	    }

	   // var colorcount = new Counter(rainbow.length);




	    /* distant */

    	var distant = {
    		walls: {},
    		createWall: function(nextcolor) {
    			window[nextcolor] = new wall("line")
    		},
    		intervals: {},
    		gens: {}
    	}

    	
    	var createGens = function(index,code) {
    		var gennames = ["bounce","gesture","markov","pick"]
    		distant.gens["line"+index] = []
    		for (var i=0;i<code.length;i++) {
    			for (var j=0;j<gennames.length;j++) {
    				if (code.slice(i).indexOf(gennames[j]+"(")==0) {
    					var end = code.slice(i).indexOf(")")+i+1
    					var linekey = "line"+index
    					distant.gens[linekey].push({
    						orig: code.slice(i,end), 
    						type: gennames[j],
    						start: i,
    						end: end
    					})
    					var genIndex = distant.gens[linekey].length - 1
    					code = code.replace(distant.gens[linekey][genIndex].orig,'distant.gens["'+linekey+'"]['+genIndex+'].generator.tick()')
    				}
    			}
    		}
    		for (var i=0;i<distant.gens["line"+index].length;i++) {
    			distant.gens["line"+index][i].generator = eval("new " + distant.gens["line"+index][i].orig[0].toUpperCase() + distant.gens["line"+index][i].orig.slice(1))
    		}
    		return code
    	}












   

    	/* NEED TO BE ENCAPSULATED (in musicians toolkit?) */




    	/* BOUNCE*/

			function Bounce(lower,upper) {

				this.value = lower

				this.upper = Math.max(lower,upper)
				this.lower = Math.min(lower,upper)

				this.beats = 16

				this.step = (this.upper - this.lower) / this.beats
				this.direction = 1

				this.tick = function() {
					this.value += this.direction * this.step
					if (this.value > this.upper) {
						this.direction = -1
						this.value = this.upper
					} else if (this.value < this.lower) {
						this.direction = 1
						this.value = this.lower
					}
					return this.value
				}
			}




    	/* PICK*/

			function Pick() {

				this.choices = arguments

				this.tick = function() {
					return this.choices[random(this.choices.length)]
				}

			}




			/* GESTURE */

			_Gesture1Buffer = [
					{x: 0, y: 1 },
					{x: 1, y: 0 }
			]

			var Gesture = function(xlow,xhigh) {

				var ylow = 0
				var yhigh = 0

				this.buffer = _Gesture1Buffer
			
				this.bufferIndex = 0
				this.speed = 1
				this.limit = 100

				this.range = {
					x: [ xlow ? xlow : 0 , xhigh ? xhigh : 1 ],
					y: [ ylow ? ylow : 0 , yhigh ? yhigh : 1 ]
				}

			}

			Gesture.prototype.setBuffer = function(buff) {
				this.buffer = buff ? buff : this.buffer
				
			}

			Gesture.prototype.kill = function() {
			}

			Gesture.prototype.tick = function() {

				this.bufferIndex += this.speed
				this.bufferIndex %= this.limit

				var interval = this.limit / this.buffer.length;

				var lowerIndex = Math.floor(this.bufferIndex/interval)
				var upperIndex = lowerIndex + 1

				upperIndex %= this.buffer.length

				var interpDistance = (this.bufferIndex - lowerIndex*interval) / interval

				var x = interp(interpDistance, this.buffer[lowerIndex].x,this.buffer[upperIndex].x)
				var y = interp(interpDistance, this.buffer[lowerIndex].y,this.buffer[upperIndex].y)

				x *= scale(x,0,1,this.range.x[0],this.range.x[1])

				return x

			}

			/* PATTERN */




			/* WANDER */



//what kind of code?
//
//major(wander(20,70))
//markov(majorscale)
//markov(majorscale) .... really don't need to do 'major' stuff yet. going to focus on samples.
//
//pattern(0,10,8) could mean create a dream6 style pattern out of 8 divisions of 0 and 10
//wander(0,10) could mean wander by step (1? 0.1?) between 0 and 10





 /* LOOP shorthand...

1 ~ pian = [] 
2 ~ -l 10 pian.push(hear("pno"))
3 ~ -l 10 pian[i].play(r(2)) @ 500

1 ~ pian = [] 
2 ~ -l 10 pian.push(hear("pno"))
3 ~ pian.each("play(600)") @ 500

1 ~ [] 
2 ~ -l 10 1 push(hear("pno"))
3 ~ 1 each("play(600)") @ 500

1 ~ []
2 ~ 1 push(hear("piano")) @ 0 10
3 ~ 1 play(r(1,2)) @ 0 10 @ 500


would you ever do -l lineNum code....?

1 ~ explore("montana")
2 ~ 1 info() -l ...






so.....


1 ~ piano = []
2 ~ -l 10 piano[i] = hear("pno")
3 ~ 1 each("play(600)") @ 500




-1 wraps a loop around the code
for (var i=0;i<10;i++) {
	piano[i] = hear("pno"))
}

-1 wraps a loop around the code
every 500ms:
for (var i=0;i<10;i++) {
	piano[i].play(r(1,2))
}

loops cannot be used accurately with: gesture, markov, bounce
*/




	</script>

  </body>
</html>