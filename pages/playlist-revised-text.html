<!doctype html>
<html>
  <head>
  <meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
  <script type="text/javascript" src="http://cdn.tonejs.org/latest/Tone.min.js"></script>
	<script src="js/bt.js"></script>
	<script src="js/lc-playlist-textinput.js"></script>
	<script src="js/translator3.js"></script>
	<script src="js/nexusUI.js"></script>
	<link href='http://fonts.googleapis.com/css?family=Anonymous+Pro:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="css/coding.css">
    <link href="./jcubic/css/jquery.terminal.css" rel="stylesheet"/>
    <script src="./jcubic/js/jquery-1.7.1.min.js"></script>
    <script src="./jcubic/js/jquery.mousewheel-min.js"></script>
    <script src="./jcubic/js/jquery.terminal-min.js"></script>
		<script src="js/jquery-ui.js"></script>
  </head>
  <body>

  	<h1>McLuhan.js *Environment*</h1>

  	<div id="main" style="margin:0 auto;width:400px;border:solid 2px #555;padding:5px 0px 0px;position:relative;overflow:hidden">

	  	<canvas id="presence" style="position:absolute;top:0px"></canvas>

		<div id="playlist"></div>

		<div id="terminal" style="z-index:2;text-align:left"></div>

	</div>

	<canvas nx="trace"></canvas>

	<div id="poemvis"></div>

	<script>

			nx.onload = function() {

				nx.colorize("black")
				trace1.nodeSize = 8
				trace1.on('*',function(data) {
					// done so that the Array object keeps its reference within all the generators. I.e. is not made into a new object.
					while (_Gesture1Buffer.length > 0) {
						_Gesture1Buffer.pop()
					}
					for (var i=0;i<data.path.length;i++) {
						_Gesture1Buffer[i] = data.path[i]
					}	

					// will need to set all generators.... 
					// maybe gens should all go to some central array?
					// or maybe they always look to some central variable <<<variable!
					// that way, if I change that one variable, they will receive it
					// instead of having to call 'setBuffer' on each gesture in kind.
				})

			}

		  var current = {
    		wall: "",
    		media: "",
    		type: "",
    		params: ""
    	}

    	var black = {test: "thing"}

    	var local = {
    		context: "black",
    		walls: [],
    		nextWall: function() {
    			var colori = local.walls.indexOf(local.context)
    			colori++
    			if (colori >= local.walls.length) {
    				colori = 0
    			}
    			return local.walls[colori];
    		},
    		intervals: {}
    	}

			$('#terminal').terminal(function(command) {
           	
       	try {

       		var info = Translate.toCode(command)
       		playlist.add(command, info, local.context )

       	} catch(e) {

       		console.log(e);

       	}

       	return false;
           	
	    }, {
        completion: ["add"],
        greetings: "",
        prompt: "~ ",
        keypress: function(e) {
        	// ~
        	console.log(e.which)
        	if (e.which==126) {
        		var nextcolor = rainbow[colorcount.tick()]
        		//distant.walls[nextcolor] = new wall("line")
        		distant.createWall(nextcolor);
        		local.context = nextcolor
        		local.walls.push(nextcolor)
        		$("#terminal").terminal().set_command("")
        		$("#terminal .cmd").css("color", local.context)
        		return false;
        	}
        	// `
        	if (e.which==96) {
        		local.context = local.nextWall();
        		//$("#terminal").terminal().set_command("")
        		$("#terminal .cmd").css("color", local.context)
        		return false;
        	}
        //  socket.emit('typing',$("#terminal .cmd span")[1].innerHTML)
        }
	    });

		var rainbow = ["red", "orange", "green", "blue", "purple" ]

		var walls = []




		/* INSTANCES */

		var playlist = new LCPlaylist("playlist", function(data) {
			
			// data.index, data.command, data.event
			console.log("playlist callback says: ", data)
			
			switch (data.event) {
				case "add":

					console.log("add", data)

					local.intervals["line"+data.index] = interval(data.duration,function(data) {
						this.ping(data)
					}.bind(this,data))


					// happens distantly
					data.gencode = createGens(data.index,data.code)
					distant.intervals["line"+data.index] = interval(data.duration,function(data) {
							//with (eval(data.wall)) {
								eval(data.gencode) // distant, most likely....
							//}
					}.bind(this,data))
				//	poemvis.add(data)
					break;
				case "playback":
				//	poemvis.highlight(data)
					try {
						eval( data.code )
					} catch(e) {

					}
					break;
			}

		})

		var poemvis = new PoemVis("poemvis")





		var sine = new Tone.SimpleSynth().toMaster()
		var poly = new Tone.PolySynth(30, Tone.SimpleSynth).toMaster();

		sine.play = function(note) {

			sine.triggerAttackRelease(note,0.1)

		}
		poly.play = function(note) {

			poly.triggerAttackRelease(note,0.1)

		}






		/*
		 interval with controllable speed / interval time
			bt.interval()
		*/

		window.VariableSpeedInterval = function(rate,func) {
			this.rate = rate
			this.on = true;
			this.event = func ? func : function() { };
			this.pulse = function() {
				if (this.on) {
					this.time.last = new Date().getTime()
					this.event();
					//var delay = force ? force : this.rate
					this.timeout = setTimeout(this.pulse.bind(this),this.rate)
				}
			}
			this.stop = function() {
				this.on = false;
			}
			this.start = function() {
				this.on = true;
				this.pulse();
			}
			this.time = {
				last: false,
				cur: false
			}
			this.ms = function(newrate) {
				var oldrate = this.rate;
				this.rate = newrate;

				this.time.cur = new Date().getTime()
				if (this.time.cur - this.time.last > newrate) {
					clearTimeout(this.timeout)
					this.pulse();
				} else if (newrate < oldrate) {
					clearTimeout(this.timeout)
					var delay = this.rate - (this.time.cur - this.time.last);
					if (delay < 0 ) { delay = 0 }
					this.timeout = setTimeout(this.pulse.bind(this),delay)
				}
			}
			this.start();
		}

		window.interval = function(rate,func) {
			var _int = new VariableSpeedInterval(rate,func)
			return _int;
		}

		/* use like this:
		    // func is optional
			var x = interval(50, function() {   bla ... })
			x.ms(100);
			x.stop()
			// later
			x.start()
			//can change function midway
			x.event = function() { ... }

		*/



		/*
		random function that executes (returns new num) each time
			this should probably be global
		*/


		window.rand = function(scale) {
			return random.bind(null,scale)
		}
		/* use like this:

		a = new Wall()
		a.moveTo(rand(WIDTH),rand(HEIGHT))
		*/

/*
		window.bounce = function(scale) {
			// what will need to happen in here?
			// 
			// new Bounce
			// or new Gesture
			// or new Generator
			/*
			 text in would be:
			 sine.play(random(20)+200) @ 200
			 sine.play(choice(20,40,60)+200) @ 200
			 sine.play(bounce(0,200)+200) @ 200
			 sine.play(A(0,200)+200) @ 200
			 // bounce is over 16 or 32 steps?
			
			 result would be....
			 sine.play(_bounce1+200)
			 sine.play(line1.gens[0]()+200)

			 but would be great to be able to compound like:
			 sine.play(choice(bounce(0,100),bounce(100,0))+200) @ 200

			 could also markov:
			 sine.play(markov1(0,0.1,0.2,0.3)) @ markov1(100,200,300,400)
			 markov1 could have built-in probabilities for each argument.
			 all of same markov's within a line could be tied together. thatd be nice!

			 so....
			 random, choice don't need gens
			 bounce, gesture, markov do need gens
			 bounce should not have ability for choice() or rand() arg
			 neither should gesture
			 neither should markov. so! fine.

			 can search for index of bounce(, gesture1x(, markov(
			 jest(0,50)

			 orrrr could.... have the first bounce() push some properties into distant.gens, then act on those properties each time.
			 but how would bounce know which properties were its?

			
		}
		
*/
	    



	    /* Ben Library */

	    var Counter = function(limit) {
	    	this.max = 0;
	    	this.current = -1;
	    	this.tick = function() {
	    		this.current++;
	    		if (this.current>=this.limit) {
	    			this.current = 0;
	    		}
	    		return this.current;
	    	}
	    	this.downtick = function() {
	    		this.current--;
	    		if (this.current <= this.limit) {
	    			this.current = this.limit-1;
	    		}
	    		return this.current;
	    	}
	    }

	    var colorcount = new Counter(rainbow.length);




	    /* distant */

    	var distant = {
    		walls: {},
    		createWall: function(nextcolor) {
    			window[nextcolor] = new wall("line")
    		},
    		intervals: {},
    		gens: {}
    	}

    	
    	var createGens = function(index,code) {
    		console.log(index)
    		var gennames = ["bounce","gesture","markov"]
    		distant.gens["line"+index] = []
    		for (var i=0;i<code.length;i++) {
    			console.log(code)
    			for (var j=0;j<gennames.length;j++) {
    				if (code.slice(i).indexOf(gennames[j]+"(")==0) {
    					var end = code.slice(i).indexOf(")")+i+1
    					var linekey = "line"+index
    					distant.gens[linekey].push({
    						orig: code.slice(i,end), 
    						type: gennames[j],
    						start: i,
    						end: end
    					})
    					var genIndex = distant.gens[linekey].length - 1
    					code = code.replace(distant.gens[linekey][genIndex].orig,'distant.gens["'+linekey+'"]['+genIndex+'].generator.tick()')
    				}
    			}
    		}
    		for (var i=0;i<distant.gens["line"+index].length;i++) {
    			distant.gens["line"+index][i].generator = eval("new " + distant.gens["line"+index][i].orig[0].toUpperCase() + distant.gens["line"+index][i].orig.slice(1))
    		}
    		return code
    	}












   

    	/* NEED TO BE ENCAPSULATED (in musicians toolkit?) */




    	/* BOUNCE*/

			function Bounce(lower,upper) {

				this.value = lower

				this.upper = Math.max(lower,upper)
				this.lower = Math.min(lower,upper)

				this.beats = 16

				this.step = (this.upper - this.lower) / this.beats
				this.direction = 1

				this.tick = function() {
					this.value += this.direction * this.step
					if (this.value > this.upper) {
						this.direction = -1
						this.value = this.upper
					} else if (this.value < this.lower) {
						this.direction = 1
						this.value = this.lower
					}
					return this.value
				}
			}





			/* GESTURE */

			_Gesture1Buffer = [
					{x: 0, y: 1 },
					{x: 1, y: 0 }
			]

			var Gesture = function(xlow,xhigh) {

				var ylow = 0
				var yhigh = 0

				this.buffer = _Gesture1Buffer
			
				this.bufferIndex = 0
				this.speed = 1
				this.limit = 100

				this.range = {
					x: [ xlow ? xlow : 0 , xhigh ? xhigh : 1 ],
					y: [ ylow ? ylow : 0 , yhigh ? yhigh : 1 ]
				}

			}

			Gesture.prototype.setBuffer = function(buff) {
				this.buffer = buff ? buff : this.buffer
				
			}

			Gesture.prototype.kill = function() {
			}

			Gesture.prototype.tick = function() {

				this.bufferIndex += this.speed
				this.bufferIndex %= this.limit

				var interval = this.limit / this.buffer.length;

				var lowerIndex = Math.floor(this.bufferIndex/interval)
				var upperIndex = lowerIndex + 1

				upperIndex %= this.buffer.length

				var interpDistance = (this.bufferIndex - lowerIndex*interval) / interval

				var x = interp(interpDistance, this.buffer[lowerIndex].x,this.buffer[upperIndex].x)
				var y = interp(interpDistance, this.buffer[lowerIndex].y,this.buffer[upperIndex].y)

				x *= scale(x,0,1,this.range.x[0],this.range.x[1])

				return x

			}




	</script>

  </body>
</html>